<section>

<h1>Hi</h1>

</section>
<section>

<h2>Before we start</h2>

<p>Why are we doing this?</p>

<aside class="notes">

<p>Elixir is still our prefered language where it makes sense. This talk is not<br>
about bashing Elixir but expaning our knowledge of functional concepts.</p>

<p>The goal is to leave here with a better understanding of fp.</p>

</aside>

</section>
<section>

<h2>Reminder: What’s great about Elixir</h2>

</section>
<section>

<h2>Fault tolerance</h2>

<ul>
  <li>concurrency (and parrallelism)</li>
  <li>horizontal scalability</li>
</ul>

</section>
<section>

<h2>primatives</h2>

</section>
<section>

<h3>concepts</h3>

<ul>
  <li>process (mini application with it’s own stack and gc)</li>
  <li>mailbox (a queue for messages to be processed)</li>
</ul>

</section>
<section>

<h3>concurrency</h3>

<ul>
  <li>spawn (create a process)</li>
  <li>send (send a message to a process)</li>
  <li>receive (grab a message from the mailbox)</li>
</ul>

</section>
<section>

<h3>fault tolerance</h3>

<ul>
  <li>link (recieve the exception from a process)</li>
  <li>trap (turn the linked exception into a message)</li>
  <li>monitor (get a notification when a process dies)</li>
</ul>

</section>
<section>

<h2>Erlang VM’s focus on stability</h2>

<ul>
  <li>performance and memory grows linearly</li>
  <li>stability and recovery more important than performance</li>
  <li>OTP’s extensive set of tools to build applications</li>
</ul>

</section>
<section>

<h2>Taking the best ideas from other communities (Ruby, Clojure, etc…)</h2>

<ul>
  <li>community driven solutions</li>
  <li>lessons learned from those communities</li>
</ul>

</section>
<section>

<h2>Desire to be inclusive</h2>

</section>
<section>

<h1>What’s wrong with Elixir</h1>

</section>
<section>

<h2>Purity</h2>

<p>A function is pure when:</p>
<ul>
  <li>it’s return value is always the same for the same inputs</li>
  <li>has no side effects (no mutation of variables, IO, references, etc..)</li>
</ul>

</section>
<section>

<p>Why is purity important?</p>

<ul>
  <li>cacheable</li>
  <li>portable</li>
  <li>testable</li>
  <li>reasonable</li>
  <li>parrallelism</li>
</ul>

</section>
<section>

<h2>Currying</h2>

</section>
<section>

<pre><code class="language-haskell">let add x y = x + y
let addOne = add 1 
addOne 5 -- returns 6
</code></pre>

</section>
<section>

<pre><code class="language-javascript">function curry(fn) {
  const arity = fn.length;

  return function $curry(...args) {
    if (args.length &lt; arity) {
      return $curry.bind(null, ...args);
    }

    return fn.call(null, ...args);
  };
}
</code></pre>

</section>
<section>

<pre><code class="language-javascript">let add = curry((x, y) =&gt; x + y)
let addOne = add(1)
addOne(5) // returns 6
</code></pre>

</section>
<section>

<pre><code class="language-elixir">defmodule Curry do
  def curry(fun) do
    {_, arity} = :erlang.fun_info(fun, :arity)
    curry(fun, arity, [])
  end

  def curry(fun, 0, arguments) do
    apply(fun, Enum.reverse arguments)
  end

  def curry(fun, arity, arguments) do
    fn arg -&gt; curry(fun, arity - 1, [arg | arguments]) end
  end
end
</code></pre>

</section>
<section>

<pre><code class="language-elixir">import Curry
add = curry(fn x, y -&gt; x + y end)
addOne = add.(1)
addOne.(5) # returns 6
</code></pre>

</section>
<section>

<pre><code class="language-elixir">defmodule Curried do
  import Curry

  def match term do
    curry(fn what -&gt; (Regex.match?(term, what)) end)
  end

  def filter f do
    curry(fn list -&gt; Enum.filter(list, f) end)
  end

  def replace what do
    curry(fn replacement, word -&gt; 
      Regex.replace(what, word, replacement) 
    end)
  end
end
</code></pre>

</section>
<section>

<pre><code class="language-elixir">has_spaces = Curried.match(~r/\s+/)

sentences = Curried.filter(has_spaces)

disallowed = Curried.replace(~r/[jruesbtni]/)

censored = disallowed.("*")

allowed = sentences.(["justin bibier", "and sentences", "are", "allowed"])
# =&gt; returns ["justin bibier", "and sentences"]

allowed |&gt; List.first |&gt; censored.() # =&gt; returns "****** ******"
</code></pre>

</section>
<section>

<h2>Composition</h2>

</section>
<section>

<pre><code class="language-javascript">const compose = (...fns) =&gt; (...args) =&gt; {
  return fns.reduceRight((res, fn) =&gt; { 
    return [fn.call(null, ...res)];
  }, args)[0];
}
</code></pre>

</section>
<section>

<pre><code class="language-javascript">const toUpperCase = x =&gt; x.toUpperCase();
const exclaim = x =&gt; `${x}!`;
const shout = compose(exclaim, toUpperCase);

shout('send in the clowns'); // "SEND IN THE CLOWNS!"
</code></pre>

</section>
<section>

<pre><code class="language-elixir">defmodule Compose do
  import Curry

  def f &lt;|&gt; g, do: compose(f, g)

  def compose(f, g) when is_function(g) do
    fn arg -&gt; compose(curry(f), curry(g).(arg)) end
  end

  def compose(f, arg) do
    f.(arg)
  end
end
</code></pre>

</section>
<section>

<pre><code class="language-elixir">import Compose

to_upper_case = fn x -&gt; String.upcase(x) end
exclaim = fn x -&gt; x &lt;&gt; "!" end
shout = exclaim &lt;|&gt; to_upper_case

shout.('send in the clowns'); # "SEND IN THE CLOWNS!"
</code></pre>

</section>
<section>

<h2>Types</h2>

</section>
<section>

<pre><code class="language-haskell">data Maybe a = Just a
             | Nothing
</code></pre>

</section>
<section>

<pre><code class="language-elixir">defmodule Maybe do
  @type t :: %__MODULE__{
    just: term,
    nothing: boolean
  }
  defstruct just: nil,
            nothing: false

  def just(v), do: __MODULE__ |&gt; struct(just: v)
  def nothing, do: __MODULE__ |&gt; struct(nothing: true)
end
</code></pre>

</section>
<section>

<h2>Functors</h2>

</section>
<section>

<pre><code class="language-haskell">class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>

</section>
<section>

<pre><code class="language-haskell">instance Functor Maybe where
    fmap _ Nothing  = Nothing
    fmap f (Just a) = Just (f a)
</code></pre>

</section>
<section>

<pre><code class="language-javascript">class Container {
  constructor(x) {
    this.$value = x;
  }

  static of(x) {
    return new Container(x);
  }

  map(f) {
    return Container.of(f(this.$value));
  }
}
</code></pre>

</section>
<section>

<pre><code class="language-javascript">let append = curry(x, y =&gt; y + x)
let prop = curry(key, object =&gt; object[key])

Container.of('bombs').map(append(' away')).map(prop('length'));
// Container.of(10)
</code></pre>

</section>
<section>

<pre><code class="language-elixir">defprotocol Functor do
  @spec fmap(t, (term -&gt; term)) :: t
  def fmap(functor, fun)
end
</code></pre>

</section>
<section>

<pre><code class="language-elixir">defimpl Functor, for: Maybe do
  def fmap(%{nothing: true} = f, _), do: f
  def fmap(%{just: a}, fun) do
    fun
    |&gt; apply([a])
    |&gt; Maybe.just
  end
end
</code></pre>

</section>
<section>

<pre><code class="language-elixir">import Compose

trimmed_length = String.length/1 &lt;|&gt; String.trim/1

Maybe.nothing() |&gt; Functor.fmap(trimmed_length)
# %Maybe{nothing: true, just: nil}
</code></pre>

</section>
<section>

<h2>Monads</h2>

<pre><code>
Confusing?

</code></pre>

<p><a href="https://wiki.haskell.org/Monad_tutorials_timeline">https://wiki.haskell.org/Monad_tutorials_timeline</a></p>

</section>
<section>

<pre><code class="language-javascript">class Maybe {
  constructor(x) {
    this.$value = x;
  }

  static of(x) {
    return new Maybe(x);
  }

  isNothing() {
    return (this.$value === null || this.$value === undefined);
  }

  map(f) {
    return this.isNothing() ? Maybe.of(null) : Maybe.of(f(this.$value));
  };
}
</code></pre>

</section>
<section>

<h2>Applicative</h2>

</section>
<section>

<pre><code class="language-elixir">defprotocol Applicative do
  @spec apply(t, Functor.t) :: t
  def apply(fun, f)
end
</code></pre>

</section>
<section>

<pre><code class="language-elixir">defimpl Applicative, for: Maybe do
  def apply(%{nothing: true} = f, _), do: f
  def apply(%{just: fun}, f) do
    f |&gt; Functor.fmap(fun)
  end
end
</code></pre>

</section>
<section>

<h1>References</h1>

<p><a href="https://mostly-adequate.gitbooks.io/mostly-adequate-guide/appendix_a.html">https://mostly-adequate.gitbooks.io/mostly-adequate-guide/appendix_a.html</a><br>
<a href="http://blog.patrikstorm.com/function-currying-in-elixir">http://blog.patrikstorm.com/function-currying-in-elixir</a><br>
<a href="https://shane.logsdon.io/writing/functors-applicatives-and-monads-in-elixir/">https://shane.logsdon.io/writing/functors-applicatives-and-monads-in-elixir/</a><br>
<a href="https://www.bignerdranch.com/blog/composing-elixir-functions/">https://www.bignerdranch.com/blog/composing-elixir-functions/</a></p>

</section>
<section>

<h1>Practice</h1>

<p><a href="https://github.com/witchcrafters/witchcraft">https://github.com/witchcrafters/witchcraft</a></p>

</section>
